<!DOCTYPE html>
<html lang="sr">
<head>
	<title>Backbone Workshop</title>
	<meta charset='utf-8'>
	<link href='http://fonts.googleapis.com/css?family=Fjord+One' rel='stylesheet' type='text/css'>
	<link href='styles/main.css' rel='stylesheet' type='text/css'>
</head>
<body>
<h1>Backbone Workshop</h1>
<nav>
	<a href="#what-is-backbone">Šta je Backbone web aplikacija</a>
	<a href="#main-app-parts">Glavni delovi aplikacije</a>
	<a href="#backbone-model">Backbone.Model</a>
	<a href="#backbone-collection">Backbone.Collection</a>
	<a href="#backbone-view">Backbone.View</a>
	<a href="#backbone-router">Backbone.Router i Backbone.History</a>
	<a href="#problems">Diskusija</a>
</nav>
<article>
	<p><a id="what-is-backbone"><h2>Šta je Backbone web aplikacija</h2></a>
	"Backbone aplikacija" je web aplikacija struktuirana na način koji je predstavljen u backbone.js bibilioteci. To je MV* arhitektura.</p>
	<p>Aplikaciju čine tri dela: Manipulacija DOM-a, Pomoćne funkcije (operacije sa objektima, operacije nad nizovima, ...) i Backbone.js bibilioteka koja određuje strukturu cele aplikacije.</p>
	<img src="images/Vozic.png" class="large">
	<p><span>jQuery</span> (ili neka druga srodna bibilioteka) služi da manipuliše DOM-om, jQuery je preporučen od strane Backbone-a, i cela komunikacija sa <span>HTML</span> dokumentom se odvija preko jQuery-a.</p>
	<p>Najčešće korištene <span>"utility"</span> biblioteke, <span>Underscore.js</span> i <span>Lodash.js</span> nude funkcionalnosti koje Backbone koristi interno, ali koje su potrebne i korisnicima za lakši razvoj aplikacije.<p>
	<img src="images/BackboneCode1.png" class="large">
	<p><span>Underscore.js</span> je <span>"hard-dependency"</span> za Backbone.js pa mora biti učitan pre <span>backbone.js</span> fajla. Takođe, ukoliko naša aplikacija koristi jQuery ili neku srodnu bibilioteku (a najverovatnije hoće), i ta biblioteka mora biti učitana pre Backbone-a.</p>
	<p>Glavne beneficije koje Backbone nudi su visok stepen <span>fleksibilnosti</span> u načinu razvoja aplikacije, precizna <span>organizacija</span> koda (što nam omogućava efikasnije dodavanje novih funkcionalnosti i izmene postojećih) i <span>kontrola</span> svih delova aplikacije (nema mnogo "magije").</p>
	<p>Pored svega ovoga, Backbone je samo Javascript <span>bibilioteka</span>, a ne frejmvork jer korisnika ne forsira da koristi ponuđene funkcionalnosti striktno "po receptu".</p>
</article>

<article>
	<p><a id="main-app-parts"><h2>Glavni delovi aplikacije</h2></a>
	<!--<span>>>Stari Grci su verovali da je sve sačinjeno od četiri elementa: zemlja, voda, vazduh i vatra.</span>-->
    </p>
	<p>Generalna podela Backbone applikacije je na:
	<ul>
	<li>Model,</li>
	<li>Collection,</li>
	<li>View i</li>
	<li>Router</li>
	</ul>
	Aplikacija je sastavljena od jednog ili više modela, kolekcija, pogleda i rutera. Ti delovi međusobno komuniciraju i omogućavaju razne funkcionalnosti. 
	<img src="images/Backbone021.png" class="large"><br>
	Ovi delovi su objekti sa predefinisanim atributima (od kojih su neki inicijalno definisani prazni), koje kada predefinišemo menjamo njihovo podrazumevano ponašanje (proširujemo funkcionalnosti).</p>
	<p>Pošto je neophodna međusobna komunikacija između različitih instanci od Backbone.View, Backbone.Model, Backbone.Collection i Backbone.Router potrebno je omogućiti njihovu međusobnu "vidljivost". Ne želimo da "prljamo" prostor globalnih varijabli sa više promenjivih iz aplikacije, pa je dobra praksa sve globalne promenjive potrebne za našu aplikaciju smestiti u jedan globalni objekat, a različite sekcije aplikacije u različite atribute tog objekta.
	Npr ovako:<br>
	<img src="images/Backbone022.png" class="verySmall">
	</p>
	<p>Ako aplikaciju pišemo unutar jednog IIFE modula ovakav "namespacing" nije neophodan, ali ne može da škodi - imamo jasan pregled na šta se odnosi bilo koja varijabla. U ostalim slučajevima je izuzetno koristan.</p>
</article>

<article>
	<p><a id="backbone-model"><h2>Backbone.Model</h2></a>
	<span>Backbone.Model</span> opisuje formu u kojoj se nalazi neki podatak unutar aplikacije, ili model iz realnog života. Npr. model automobila bi sadržao glavne podatke o automobilu: model, godište, potrošnja...</p>
	<p>Običan Javascript objekat je takođe jedan model, a Backbone.Model uz sve to nudi funkcionalnosti koje se skoro uvek koriste. Npr. često čitamo vrednosti modela, ili menjamo neke atribute (za to su definisane funkcije <span>get()</span> i <span>set()</span> ), proveravamo validnost vrednosti atributa modela ( <span>validate()</span> ), dalje, ukoliko je potrebno dovući podatke sa mreže, metode za učitavanje podataka u model ( <span>fetch()</span> ).
	</p>
	<p>Moguće je i postaviti podrazumevane vrednosti za atribute modela, što definišemo u <span>defaults</span> objektu. Osim ovih, postoji još veliki broj mogućnosti koje nudi Backbone.Model, a sve su opisane u Backbone dokumentaciji (<a href="http://backbonejs.org/#Model">http://backbonejs.org/#Model</a>).</p>
	<p>Primer definicije jednog Backbone modela: <br>
	<img src="images/BackboneModel.png" class="medium">	
	</p>
	<p>Kada se instancira Backbone.Model (npr <br><span>var Knjiga = new Backbone.Model.extend({<br>
		&nbsp;defaults: {<br>
		&nbsp;author: "Unknown", <br>
		&nbsp;bookTitle: "Blank"<br>
		}<br>
		});<br>
	var model = new Knjiga();<br>
	</span>)<br>automatski se pozove <span>initialize()</span> metod iz Backbone.Model, i kao parametre primi ono što je prosleđeno konstruktoru. Međutim, argumenti <span>initialize()</span> nisu obavezni, ali mogu biti korisni u nekim situacijama - da kontruišemo model na različite načine pomoću promene parametara kontruktora (kao Facade patern).<br>
	<span>initialize()</span> metod je dostupan i u drugim Backbone objektima.
	</p><p>Kada smo, u primeru iznad, izveli (nasledili) jedan View objekat iz Backbone.View objekta koristili smo funkciju <span>extend()</span> koja potiče iz Underscore.js (ili Lodash.js).</p>
</article>

<article>
	<p><a id="backbone-collection"><h2>Backbone.Collection</h2></a>
    Backbone kolekcija je uređen skup modela. Npr. ako imamo model <span>Automobil = Backbone.Model;</span> onda možemo imati kolekciju <span>Automobili = Backbone.Collection({ model : Automobil });</span> Najčešće koristimo kolekcije čiji su svi modeli istog tipa, ali takvo ograničenje ne postoji.
        Ukoliko apstraktnije posmatramo Backbone kolekciju, vidimo da je to niz objekata sa pomoćnim metodama koje nam omogućavaju manipulaciju, npr. sortiranje ( <span>sort()</span> ), filtriranje ( <span>filter()</span> ), izmene pojedinih objekata, dodavanje objekata u kolekciju ( <span>add()</span> ), brisanje ( <span>remove()</span> ), kao i operacije za popunjavanje kolekcije podacima sa mreže ( <span>fetch()</span> ), itd.
	</p>
    <br><img src="images/BackboneCollection.png" class="medium"><br>
    Kolekcije i modeli igraju veoma važnu ulogu u (možda) najbitnijem delu aplikacije, View-u, jer se u njima nalaze svi podaci koji će biti predstavljeni korisniku. Posledica većeg dela korisnikovih akcija će rezultovati promene modela i kolekcija u aplikaciji.

    <p>U funkciji <span>Backbone.sync</span> je definisan način na koji će se podaci iz modela (kolekcija) slati na server, i ukoliko treba da napravimo neke izmene u odnosu na podrazumevani način komunikacije potrebno je da predefinišemo tu funkciju. Ovu funkciju interno koriste metodi <span>fetch()</span> iz modela i kolekcije. </p>
    <p>Unutar Backbone.Collection objekta raspolazemo sa metodama <span>initialize() [prazan], toJSON(options) [mapira toJSON(options) iz Backbone.Model], sync() [Backbone.sync], add(models, options), remove(models, options), set(model, options), reset(models, options), push(models, options), pop(options), unshift(model, option) [dodaje model na početak], shift(options) [skida model sa početka kolekcije], slice(), get(obj), at(index), where(attrs, first), findWhere(attrs), sort(options), pluck(attrs), fetch(options), create(models, options), parse(resp, options) [return resp], clone(), modelId(attrs).</span> itd.
    </p>
    <p>Backbone.Model, Backbone.Collection i Backbone.Router su unutar Backbone biblioteke fizički odvojeni, ali čine jednu celinu - deo aplikacije koji se bavi podacima.</p>
</article>

<article>
	<p><a id="backbone-view"><h2>Backbone.View i Backbone.Event</h2></a>
    Osnovna svrha instanci <span>Backbone.View</span> objekta je da prikažu podatke sačuvane u modelima i kolekcijama, ili podatke nastale tokom izvršavanja aplikacije. Pored toga, Backbone.View ima zadatak da osluškuje događaje, i na njih adekvatno reaguje.</p>
    <p>Kao i drugi Backbone objekti, i Backbone.View ima više atributa koje možemo predefinisati.
        <p><span>var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];</span></p>
        Prvi od njih je <span>el</span> atribut, čija je vrednost DOM reprezentacija objekta kojim upravlja taj View (pored <span>el</span> često pristupamo <span>$el</span> atributu koji se interno pravi i to jQuery objekat napravljen od <span>el</span> - <span>$(el)</span>). Kada se kaže da <span>View kontroliše (upravlja) neki DOM element</span>, misli se da View ima mehanizme da menja taj element, da osluškuje njegove događaje, da ga sakrije, prikaže, obriše, itd.
    </p>
    <p>Primer jednog Backbone.View objekta: <br>
        <img src="images/BackboneView01.png" class="medium"><br>Dakle, ovde je SearchView "prikačen" za $('#search_container') DOM element, i taj element popunjava sadržajem po uzoru na <span>templejt</span> koji se nalazi u $('#search_template').</p>
    <p>U prethodnom primeru smo videli da u jednom redu piše: <br>
        <span>var template = _.template( $("#search_template").html(), {} );</span> <br>
    Na prvi pogled deluje nejasno, al zapravo je prilično jednostavno. Radi se o <span>template()</span> funkciji iz <span>Underscore.js</span> biblioteke (<a href="http://underscorejs.org/#template">http://underscorejs.org/#template</a>). Prvi parametar je string (HTML sadržaj) koji, opciono, može da zavisi od nekih promenjivih. Drugi parametar je objekat koji sadrži vrednosti promenjivih da se HTML element kompletira. U prethodnom slučaju nije bilo promenjivih, pa je zato prosleđeni objekat prazan. Istini za volju, <span>var template = _.template( $("#search_template").html(), {} );</span> je kao da smo pozvali <span>var template =  $("#search_template").html();</span>.</p>
    <p>Primer: Kako može da izgleda neki element napravljem pomoću šablona (templejta) sa različitim podacima. <br><img src="images/BackboneTemplate01.png" class="medium"><br><img src="images/BackboneTemplate02.png">&nbsp;<img src="images/BackboneTemplate03.png"></p>
    <p>Često je zgodno napraviti pomoćnu <span>template( element )</span>  funkciju, da bismo imali lepši zapis prevođenja templejta.<br>
        <img src="images/Template.png" class="small"><br>
        Ovoj funkciji je potrebno proslediti samo <span>id</span> HTML elementa u kojem se nalazi templejt, a kao rezultat dobićemo funkciju koja prima objekat (u obliku key:value) sa promenjivim potrebnim da se dobije konačan HTML element.</p>

    <p>Metod koji ćemo vrlo često hteti da predefinišemo (jer je skoro prazan) je <span>render()</span>. Po konvenciji taj metod vraća <span>this</span>, a služi da DOM element popunimo sadržajem. Metod <span>render()</span> ćemo pozvati kada želimo da apdejtujemo sadržaj, to može biti relativno često, pa nije poželjno da unutar tog metoda imamo neku kompleksnu logiku - ukoliko je tu kompleksna logika, nešto radite pogrešno.
    </p><p><span>initialize()</span> metod se poziva kada se kreira nova instanca tog objekta, isto kao kod Modela i Kolekcije.</p>
    <p>
        Treba primetiti se unutar nekog View objekta vide svi DOM elementi na stranici, ne samo onaj kojim upravlja taj View. To ne iznenađuje jer ne postoji poseban mehanizam enkapsulacije, a osim toga Backbone ima pristup jQuery objektu, jQuery celom DOM drvetu, tako da je jasno zašto je tako.
        Zbog toga je lako upasti u zamke prilikom pisanja aplikacije, koje će dovesti do upotrebe anti-paterna. Npr. situacija kada View pristupa DOM elementima na stranici za koje nije odgovoran je jedan anti-patern, jer suština postojanja View objekta je da se različitim delovima aplikacije dodele različiti objekti koji će da kotrolišu odgovarajuće delove.</p>
    <p>Unutar Backbone.View objekta raspolažemo sa metodama: <span>$(selector) [to je zapravo $.find() unutar instance View], initialize() [prazan], render() [samo return this;], remove() [$.remove i stopListening], setElement(element), delegateEvents(events), delegate(eventName, selector, listener), undelegateEvents(), undelegate(eventName, selector, listener)</span>
    </p>
    <p>
        Vidimo da unutar Veiw objekta imamo dosta metoda koje osim što se bave DOM strukturom stranice, upravljaju i događajima. Događaje (event, eventListener)
 teško da možemo logički razdvojiti od izgleda (prikaza i UX) aplikacije. Većina elemenata na stranici treba da ponudi interaktivnost sa korisnikom, pa je reagovanje da korisnikove akcije sastavi deo View infrastrukture. </p>
    <p>Događaji se definišu unutar Backbone.View objekta u <span>events</span> atributu, koji sadrži uređene parove <span>'događaj':'akcijaNaDogađaj'</span>. Na primer:<br>
    <img src="images/Events.png"><br>
    </p>
    <a href="http://backbonejs.org/docs/backbone.html#section-18"><span>Backbone.Events</span></a> pruža sličan interfejs kao i jQuery za rad sa događajima. Bitno je obratiti pažnju da kada se neki element uklanja iz Backbone.View objekta da li se istovremeno uklanja i eventListener za taj događajaj. Preporuka je koristiti metod <span>listenTo</span> umesto <span>on</span>. Tako kada treba ukloniti neki View (element iz DOMa) pored <span>this.$el.remove();</span> treba pozvati i <span>Backbone.View.undelegateEvents.call(this)</span>.
</article>

<article>
	<p><a id="backbone-router"><h2>Backbone.Router</h2></a>
        <span>Backbone.Router</span> povezuje određene URL adrese unutar aplikacije i oglašava događaje kada dođe do promene adrese. Dalje, te događaje možemo da povežemo sa adekvatnim akcijama. Praktično, to može da izgleda ovako: <br>
        <img src="images/Router01.png" class="medium"><br>
        Pored očigledne mogućnosti da različitim delovima aplikacije pristupamo preko URL adrese i da na osnovu parametara adrese dobijamo potrebne informacije,
 sa pozicije developera, Router pomaže da (potencijalno veliku)	aplikaciju razbijemo na manje celine preko različitih adresa, a zatim delove aplikacije razvijamo nezavisno od ostatka.</p>
<p>Unutar Backbone.Router objekta od koristi su funkcije <span>navigate()</span> [pomoću koje menjamo trenutnu adresu brauzera (logički gledano, to znači da prelazimo iz jednog dela aplikacije u drugi). Takav poziv se najčešće nalazi unutar nekog eventHandler-a koji treba promeni trenutni pogled aplikacije.], dalje imamo <span>execute()</span>, kao i <span>initialize()</span>. </p>
   <p> <a href="http://backbonejs.org/docs/backbone.html#section-198"><span>Backbone.History</span></a> je objekat koji služi za upravljanje istorijom brauzera, praćenjem promena ruta (route), itd...
Sadrži veći broj metoda i atributa o kojima sada neće biti reči. Značajan nam je metod <span>start()</span> koji pokreće praćenje hash promena u brauzeru, praktično omogućava da se na hash-promenu rute ispali događaj.
    </p>
</article>


<article>
	<p><a id="problems"><h2>Diskusija</h2></a> </p>
    <p>Kako proširiti (ekstendovati, naslediti) Backbone.View</p>
    <p><span>this.$el.append()</span> VS <span>document.createDocumentFragment()</span> </p>
    <!--http://elving.me/post/48040344160/rendering-backbone-collections-with-->
    <p>Kako promeniti smer sortiranja kolekcije(rastuće, opadajuće)</p>
    <p>Obostrano povezivanje u Backbone (Two-way binding)</p>

</article>
</body>
</html>
